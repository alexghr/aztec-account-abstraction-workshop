{
  "name": "Counter",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+2diZdfRZXH+6WXpFIBUeM4DgPCICIiklSDjCJjkFFkEEGRUWQUIgnILpuIGzoMIiIgm4iI4igwiowCo8hIIIQlQASCAULI1gFx+yvMfV3f9JdKpU7/jvf6e31S95w+feu9rvp+7r31W+ptPXNgYKAZGLfBjT9DA5sb9s+Lv+f8dTa30RtrjiXntCnCOajI2cR5YMk7ZJBXbcbhKcA4olx3MOI9YPrGnxkbf9zGn5kbfx5x49vl13D8G8wVR/2m0bbBJHZH+2Ej5M/TiWd0RD/fc4Yj/wD95ni3jbHM1NUNLtHjfKZ5GyB9YfG6LHOEY1aSA9HZRlen/YyYlcSHNrQ8MXhDFp/RNtAJLolZrFTnbagO20Z/FvG9QjkPDelgXLRfQXWYRb4Vi89oG+gEl8QsVqoJ9KXfdtHflvheqZyHhnQwLtqvpDpsS74Vi89oG+gEl8QsVqoJ9KXfq6K/HfG9WjkPDelgXLRfTXXYjnwrFp/RNtAJLolZrFQTZpmty9J+Rr0mjvUq0vk75dw2pINx0YYW53+2IYvPaBvoBJfELFaqM/Sl32uj/xri+3vlPDSkg3HRhhbnarYhi89oG+gEl8QsVqoJ9KXf66L/WuL7B+U8NKSDcdGGFudqtiGLz2gb6ASXxCxWqgn0pd/20X8d8f2jch4a0sG4aEOLc+UNWXxG20AnuCRmsVJNoC/9doj+9sS3o3IeGtLBuGjvSHXYnnwrFp/RNtAJLolZrFQT6Eu/10d/B+LbSTkPDelgXLR3ojrsQL4Vi89oG+gEzi2sVJOd4m/pt3P0X098/6Sch4Z0MC7a0OJceUMWn9E20AkuiVmsVBPoS79dor8z8b1BOQ8N6WBctN9AddiZfCsWn9E20AkuiVmsVBPoS79do78L8b1ROQ8N6WBctN9IddiFfCsWn9E20AkuiVmsVBPoS7/dor8r8b1JOQ8N6WBctN9EddiVfCsWn9E20AkuiVmsVBPoS7/do78b8b1ZOQ8N6WBctN9MddiNfCsWn9E20AkuiVmsVBPoS789or878b1FOQ8N6WBctN9CddidfCsWn9E20AkuiVmsVBPoS789o78H8b1VOQ8N6WBctN9KddiDfCsWn9E20AkuiVmsVBPoS7+9or8n8c1RzkNDOhgX7TlUhz3Jt2LxGW0DneCSmMVKNYG+9Jsb/b2ILyjnoSEdjIt2oDrsRb4Vi89oG+gEl8QsVqoJs+yty7K3sIz2wLI3seyjy9JOvbeRFrig42k/z4O36XK0c3KfJH60ma+ybt2sjrbN7TMLv3eN2rHs7TPaBjrBJTGLld6XuCb7Rn8f4vtnXb62JvsmLGhDi3PlDVl8RttAJ7gkZrFSTZjlHaoso+1567f3wPIOYtlPlWX8c+udpAUu6Hjaz/Pgnboc7ZzcL4kfbearrJW1slbWylpZK2tlrayVtbJW1spaWStrZa2slbWyVtbKWlkra2WtrJW1slbWylpZK6s+q6Nt+/aZha8lebsZy+gcn9E2iDm4JGax0nUiXJP9o78f8f2LLl9bk/0TFrShxbnyhiw+o22gE1wSs1ipJswyT5UltNcRvasHlnnEcoAqy/h1RO8mLXBBx9N+ngfv1uVo5+QBScxoM19lrayVtbJW1spaWStrZa2slbWyVtbKWlkra2WtrJW1sk4VVkfb9u8zCx+Lf5cZS2jPw6TaBjEHl8Qs1iTteeRzTQ6M/gHE96+6fG1NDkxY0IYW58obsviMtoFOcEnMYqWaMMt7dVna55C8pweW9xLLQbos7XmY95EWuKDjaT/Pg/fpcrRz8qAkfrSZr7Ju3ayOth3YZxZ+73qPHUv7HJJU20AnuCRmsdL7Etfk4OgfRHz/psvX1uTghAVtaHGuvCGLz2gb6ASXxCxWqgmzvF+VZW57/cAhPbC8n1gOVWUZ/9z6AGmBCzqe9vM8+IAuRzsnD03iR5v5KmtlrayVtbJW1spaWSvr1s3qaNvBfWbhtcwhZixz2+OvqbZBzMElMYuV1ilck8OifyjxHa7L19bksIQFbWhxrrwhi89oG+gEl8QsVqoJs3xIlWV8HfvBHlg+RCxHqLKMr2M/TFrggo6n/TwPPqzL0c7JI5L40Wa+ylpZK2tlrayVtbJW1sq6dbM62nZYn1l4LfNBM5bxdWyqbRBzcEnMYqV1CtfkyOgfQXz/rsvX1uTIhAVtaHGuvCGLz2gb6ASXxCxWqgmzfNSA5SM9sHyUWI7SZWnXsR8jLXBBx9N+ngcf0+Vo5+RRSfxoM99UYXW07cg+s/Br7CN2LMFntC10XBKzWOn1wzU5OvpHEd9/6PK1NTk6YUEbWpwrb8jiM9oGOsElMYuVasIsnzBg+XgPLJ8glmN0Wdr312NJC1zQ8bSf58GxuhztnDwmiR/tY2n7VGF1tO3oPrPwa+zjdizt+2uqbaHDuYWVXj/Hxt/Sb370jyG+T+rytTWZn7CgDS3OlTdk8RltA53gkpjFSjWBvvQ7LvrziW+Bch4a0sG4aC+gOswn34rFZ7QNdIJLYhYr1QT60m9h9I8jvuOV89CQDsZF+3iqw3HkW7H4jLaBTnBJzGKlmkBf+p0Q/YXE9ynlPDSkg3HR/hTVYSH5Viw+o22gE1wSs1ipJtCXfidG/wTiO0k5Dw3pYFy0T6I6nEC+FYvPaBvoBJfELFaqCfSl38nRP5H4TlHOQ0M6GBftU6gOJ5JvxeIz2gY6wSUxi5VqAn3pd2r0Tya+05Tz0JAOxkX7NKrDyeRbsfiMtoFOcEnMYqWaQF/6nR79U4nv08p5aEgH46L9aarDqeRbsfiMtoFOcEnMYqWaQF/6nRH904nvTOU8NKSDcdE+k+pwOvlWLD6jbaATXBKzWKkm0Jd+Z0X/DOI7WzkPDelgXLTPpjqcQb4Vi89oG+gEl8QsVqoJ9KXfOdE/i/g+o5yHhnQwLtqfoTqcRb4Vi89oG+gEl8QsVqoJ9KXfudE/h/g+q5yHhnQwLtqfpTqcQ74Vi89oG+gEl8QsVqoJ9KXfedE/l/g+p5yHhnQwLtqfozqcS74Vi89oG+gEl8QsVqoJ9KXf56N/HvF9QTkPDelgXLS/QHU4j3wrFp/RNtAJLolZrFQT6Eu/L0b/88T3JeU8NKSDcdH+EtUBDLMNWXxG20AnuCRmsVJNoC/9zo/+F4nvy8p5aEgH46INLc7VbEMWn9E20AmcW1ipJl+Ov6XfV6J/PvH9p3IeGtLBuGhDi3M125DFZ7QNdIJLYhYr1QT60u+C6H+F+P5LOQ8N6WBctKHFufKGLD6jbaATXBKzWKkm0Jd+F0b/AuL7qnIeGtLBuGh/lepwAflWLD6jbaATXBKzWKkm0Jd+F0X/QuL7mnIeGtLBuGh/jepwIflWLD6jbaATXBKzWKkm0Jd+F0f/IuL7unIeGtLBuGh/nepwEflWLD6jbaATXBKzWKkm0Jd+l0T/YuL7hnIeGtLBuGh/g+pwMflWLD6jbaATXBKzWKkm0Jd+l0b/EuK7TDkPDelgXLQvozpcQr4Vi89oG+gEl8QsVqoJ9KXf5dG/lPi+qZyHhnQwLtrfpDpcSr4Vi89oG+gEl8QsVqoJ9KXfFdG/nPiuVM5DQzoYF+0rqQ6Xk2/F4jPaBjrBJTGLlWoCfel3VfSvIL6rlfPQkA7GRftqqsMV5Fux+Iy2gU5wScxipZpAX/pdE/2riO9bynloSAfjov0tqsNV5Fux+Iy2gU5wScxipZpAX/pdG/1riO/bynloSAfjov1tqsM15Fux+Iy2gU5wScxipZpAX/pdF/1rie87ynloSAfjov0dqsO15Fux+Iy2gU5wScxipZpAX/pdH/3riO+7ynloSAfjov1dqsN15Fux+Iy2gU5wScxipZpAX/rdEP3rie97ynloSAfjov09qsP15Fux+Iy2gU5wScxipZpAX/p9P/o3EN+NynloSAfjon0j1eEG8q1YfEbbQCdwbmGlmtwYf0u/H0T/+8T338p5aEgH46INLc6VN2TxGW0DneCSmMVKNWGWH+mytP+H4Yc9sPyIWG7SZWnv77uZtMAFHU/7eR7crMvRzsmbkvjRZr7KunWzOtr2gz6z8HvXD+1Y2v/DkGob6ASXxCxWel/imtwS/ZuI7390+dqa3JKwoA0tzpU3ZPEZbQOd4JKYxUo1YZafqLKE9vmVP+6B5SfEcqsqy/jn1k9JC1zQ8bSf58FPdTnaOXlrEj/azFdZK2tlrayVtbJW1spaWStrZa2slbWyVtbKWlkra2WtrFOF1dG2W/rM4onhx2YsoX3+eqptEHNwScxipePsXJPbon8r8f2vLl9bk9sSFrShxbnyhiw+o22gE1wSs1ipJszyc1WW8fMwP+uB5efEcrsqy/h5mDtIC1zQ8bSf58EduhztnLw9iR9t5quslbWyVtbKWlkra2WtrJW1slbWylpZK2tlrayVtbJW1qnC6mjbbX1m4WPxPzNjGT8Pk2obxBxcErNY6Tg71+TO6N9OfP+ny9fW5M6EBW1oca68IYvPaBvoBJfELFaqCbP8UpVlbnse5hc9sPySWO5SZRk/D/Mr0gIXdDzt53nwK12Odk7elcSPNvNV1spaWStrZa2slbWyVtatm9XRtjv7zMJrmV+Yscxt17GptkHMwSUxi5XWKVyTu6N/F/H9vy5fW5O7Exa0ocW58oYsPqNtoBNcErNYqSbMco8qy/g69tc9sNxDLItUWcbXsfeSFrig42k/z4N7dTnaObkoiR9t5quslbWyVtbKWlkra2WtrFs3q6Ntd/eZhdcyvzZjGV/HptoGMQeXxCxWWqdwTe6L/iLiW6zL19bkvoQFbWhxrrwhi89oG+gEzi2sVJPFxLJElWV8HXt/DyxLiOUBVZbxdeyDpAUu6Hjaz/PgQV2Odk4+kMSPNvNV1spaWStrZa2slbWyVtatm9XRtvv6zMJrmfvNWMbXsam2QczBJTGLldYpXJOHov8A8T2sy9fW5KGEBW1oca68IYvPaBvoBJfELFaqCbM8osvS/n+YpT2wPEIsj+qytOvYx0gLXNDxtJ/nwWO6HO2cfDSJH23mq6xbN6ujbQ/1mYXfu5basbT/HybVNtAJLolZrPS+xDVZFv1Hie83unxtTZYlLGhDi3PlDVl8RttAJ7gkZrFSTZjlCV2W9nPr8R5YniCWJ3VZ2s+t5aQFLuh42s/zYLkuRzsnn0ziR5v5KuvWzepo27I+s/B71+N2LO3nVqptoBNcErNY6X2Ja/JU9J8kvt/q8rU1eSphQRtanCtvyOIz2gY6wSUxi5VqwixPG7Cs6IHlaWJ5Rpel/dx6lrTABR1P+3kePKvL0c7JZ5L40Wa+qcLqaNtTfWbh19gKO5bgM9oWOi6JWaz0+uGarIz+M8T3nC5fW5OVCQva0OJceUMWn9E20AkuiVmsVBPoS79V0V9JfM8r56EhHYyL9vNUh5XkW7H4jLaBTnBJzGKlmkBf+q2O/iriW6Och4Z0MC7aa6gOq8i3YvEZbQOd4JKYxUo1gb70Wxv91cS3TjkPDelgXLTXUR1Wk2/F4jPaBjrBJTGLlWoCfem3PvpriW9MOQ8N6WBctMeoDmvJt2LxGW0DncC5hZVqMhZ/S78N0V9PfC8o56EhHYyLNrQ4V96QxWe0DXSCS2IWK9UE+tLvxehvIL7fKeehIR2Mi/bvqA4byLdi8RltA53gkpjFSjWBvvR7KfovEt/vlfPQkA7GRfv3VIcXybdi8RltA53gkpjFSjVhlj/qsowKyx96YPkjsfxJl6U91vBn0gIXdDzt53nwZ12Odk7+KYkfbearrPqsjra91GcWfj/4gx3LqN9CHkaIQ2xo489l0yc4XlTmkJzwZ9H5xACtQfqbq90E15WRaybt5/opf9do3yv4uwY0oTNzIP+dYkyXY66MsT7DMUYcue+b2msUGWNthmMdceTWIhbr117WSryWtji+0ctamo+1WBz/6uVYCx+Lszg+2suxOD5Wa3Guo5djtXyuw+IcUC/nXfgckMU5wl7OR+XO2/LrXPnaiuJ5W2jxMYcXDVl8RpvzsLoDeQDDhj7mYVUH8gCG9X3Mw8oO5AEM0/qYh2c6kAcwDPYxDys6kAcwDP2N82BxrZuj8fnc9uMGuYUOxkX7ccpt7poZbRaf0TbQGXVJzGKl7wXMonytZ7sGW0Za4OJrW7GfP/+XKee+IU2MizbzTZZ1wxRiXd9nVot5ZXCt+OisjWPMoFw+luSU41G+f6bn69T5/pmluizta/Zh0gIXdDzt588ii3u6libxo818k2Vd1mdWA92AOftoovWbJA+ibXFPYC/3n/H9iRbPLllCWuk9h5728/fpJbocxXtDmW+yrEv7zGpQq71lzPt1x9z0OkAu0/uUOZ77lLXldbB44OVWeh3wvcnKz5tqXwf8vKnF8Tc/Xwv7eT2l/Ezcdm7dm8SPNvNNlnVJn1kNajUqY+o+F3nidbA4jndPklPON56vJp/hmAs4NzJI+4+ZMfF3O86YyMeYcj4c6cMmc72OwbmS9nXE5yjAxdev5Y5brtXlaOfmuiR+tJlvsqwbphDr+j6zWswrg/Npm9YtyOWaJKccT5fOn63SZWlfs8+RVnr9saf9vG6xuHZ/S9eJM99kWdf2mdXiXCfm7OpEa12Sh66d27S4d+pp0krvLfG0n9ctyudYi/cAMd9kWVf1mdWgVu26ZYXumJteB8hlej8ax/OUsra8DnB+GlZ6HfBxeuVz2e3rgM+BgIvv78V+Xrcon5do59byJH60mW+yrE/3mdWgVqMG5502vQ6QyyeSnCIembPTk23yWX5FXZe0Vtcl9qx1XTIpq+uSaDJGXZfos9Z1yQRLXZdMjrWuSyZlk16X8PcxbOPvYy6OM0B/J/uvmjFRGxjPozHdeOZO5vsaswx3iMXy3oReWZZ2iGWwQyzTO8Qy0iGWJR1iGeoQy4wOsSzqEEvTZxY3sPl3Lkf7N9C2aUlf+cy4w03sxzpxWmac9QOb/x3HbvFMDtaZR22+/6tJ+PrJsqhDLDM6xDLUIZYlHWIZ6RDL9A6xDHaIZWmHWDZ0iGW4QyzTMizKxznb4ws4Hig2Fn+vJQ4w8f2/q5VzImM8n+FYTRzQNzxG2N6b/VyGYxVxQJ+Pf63U5WjPdTCHWOl7E98np3w8rJ0jfDwFXPxMSuznZ3spH19pXzfPJvGjzXyTZV0zhVif7zOrwbw63uDY36ZzHcjl00lOOd98Hx+247NokPY3cS2xzcCWj5MpH/crrpGgtaW1Y79ZpneIZU2HWEY6xLKkQyxDHWJZ1yGWpR1iGewQy4wOsQx3iKXpM8uWjtlhPz9rFdcX8TNxp2XGw7zD30u+76Zje7gWjo/t4VqlwYzeUxmu5Zm+nEvl6/1edr0Y1n/LEz4+Bri8AyzDHWKZ0SGWwQ6xLO0Qy7oOsQx1iGVJh1hGOsSypkMs0zvEsqhDLNMyLMrXUvf8LDXoy7qfP+dXJPy8Vld+zkt7fIyfvQHNxyl36XNB2Jf3J7xf4u8Gaf8COv4g/Mt0+dtjr49l+JcRP1hy/9dT+NckMQ3S/pMS/kd1+dtjpcwlVpoz/H8klZ8fstkzO8AFHX4OBq9jHtblaF/TjyTxo818k2X97RRiXdFnVot5JWM+pDvmpmOlyOVDSU45Hu1nT8hrlv+fvVjpNcv/s/x+XZb2NbuYtMAFHU/7+ZjMYl2Odm7dn8SP9mLaPlnWJVOIddEUYn24z6yOtj1I26YlzPI9NveMb7EXyOdjWAMDL38e9wu0b4NurD3fz8XX367XZZkjunzsdx5psK7lfUZN/En/T9Ig+Te7iXzkniEOZqnhWObvcvdW8f+1wf4x45i39D+QoCXfKa+nWMcy3CPEjf18r92YMreMsYE4RhI2voaQn6dvef1Imj++T+6lTL6UWUZ9Rpv/HwLylf4/hCFlDj5WDCu9l0Bfvv/sEP0TFp59+DmfPOXE4w5ZeN4Bpy04fP6ZZ584/5QDFiw4c+FZZzU0KIQGM0J8IHo4+Tt+k8a+6TEhw7oJaRfSQwOTT8gwJWTWREKOWHjcmQvP3pgQjn8oiXXawObxc9wjAxMHVebpxDcHrLAhyqcYH+DihZbT5ZgLrZTDEccM8rFvJjFhm094eb5wX+TVU8xpbdUCBGATYQZjkMMEz4FPjwFwkGJ/AYuLAJeetwEA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "headstart",
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 120
          },
          "visibility": "private"
        },
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_counter",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "field"
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "increment",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "owner",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3d+O5bhxwOF3metFcFj/ta8S5MJIHMCA4QSx74x998jAnp4xJI92QU7rJ4lXXgPqc4pFdLHI6U/8+5c//89//uFvf/qfv/z1y89///L6t+XLz//+9y9//d8//OUf//+vf/vD//3ty8+vn7788S//tf7vLz99+e8//fmPX35uv/y0eUqshf765PrfmR9P67Lz+PrA++HX1w9W/eU/flrjaC9KII0SiFACUUogRgnEKYEEJZCkBFKUQCiVVSiVVSiVVSiVVSiVVSiVVSiVVSiVVSiVVSiVVSiVVSmVVSmVVSmVVSmVVSmVVSmVVSmVVSmVVSmVVSmV1SiV1SiV1SiV1SiV1SiV1SiV1SiV1SiV1SiV1SiV1SmV1SmV1SmV1SmV1SmV1SmV1SmV1SmV1SmV1SmVNSiVNSiVNSiVNSiVNSiVNSiVNSiVNSiVNSiVNSiVNSmVNSmVNSmVNSmVNSmVNSmVNSmVNSmVNSmVNSmVtSiVtSiVtSiVtSiVtSiVtSiVtSiVtSiVtSiVtSiVdaFU1oVSWRdKZV0olXWhVNaFUlkXSmVdKJV1oVTWhVJZ24tSWtuLUlvbi1Jc24tSXduLUl7bi1Jf24tSYNuLUmHbi1Ji2wtTY0EcC1NjOSCLI7I4JItjsjgoi6OyOCwL47IaBmY1jMxqGJrVMDarYXBWw+ishuFZDeOzGgZoNYzQahii1TBGq2GQVsMorYZhWg3jtBoGajWM1GoYqtUwVqthsFbDaK2G4VoN47UaBmw1jNhqGLLVMGarYdBWw6ithmFbDeO2GgZuNYzcahi61TB2q2HwVsPorYbhWw3jtxoGcDWM4GoYwtUwhqthEFfDKK6GYVwN47gaBnI1jORqGMrVMJarYTBXw2iuhuFcDeO5GgZ0NYzoahjS1TCmq2FQV8OoroZhXQ3juhoGdjWM7GoY2tUwtqthcFfD6K6G4V0N47saBng1jPBqGOLVMMarYZBXwyivhmFeDeO8BOO8BOO8BOO8BOO85EWpsYJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXoJxXopxXopxXopxXopxXvqi1FjFOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/FOC/DOC/DOC/DOC/DOC97UWqsYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXYZyXY5yXY5yXY5yXY5yXvyg11jHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOyzHOKzDOKzDOKzDOKzDOK16UGhsY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY5xUY55UY55UY55UY55UY55UvSo1NjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPNKjPMqjPMqjPMqjPMqjPOqF6XGFsZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5FcZ5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x5Ipx5Ipx5Ipx5IZx5IZx5IZx5IZx5LZC1NtjWPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJjGPJnGPJnGPJnGPJnGPJ/IWpts6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZM6xZMGxZMGxZMGxZMGxZPHCVNvgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLgWLLkWLLkWLLkWLLkWLJ8YaptcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcixZcSxZcSxZcSxZcSxZvTDVtjiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWrDiWbOFYsoVjyRaOJVs4lmx5YartwrFkC8eSLfuWrIXarz/2jxtsvh9QNX9/RfnX73DdeVg15NeHVcu/ffgd0G7NPTOg3cp7YkD7uuzMgHar8JkB7dbiMwParchnBrRbl88MaLc6nxnQbo0+MyBapd7XaGcGRKvU+zLtzIBolXpfqZ0ZEK1S74u1MwOiVep9vXZmQLRKvS/ZzgyIVqn3VduZAdEq9b7l+mEBtba8P1e+fmzFRzifW4UOw/nc37Bm+v5cs71wBvx+vfRrOO374Yja+4NFMz4eXl57sb+yvaN4lXz78K/R76Ony0Q/4Df3xOgHNGQ/LPr28cmtfXPw9U30A7q3E6MfUGJPjH5ARf5x0dvrI/pvPvmb6Ac0kSdG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l8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzCpmdV8jsvEJm5xUyO6/4UjljQ2bnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1XyOy8QmbnFTI7r5DZeYXMzitkdl4hs/MKmZ1Xyuy8UmbnlTI7r5TZeeWXyhmbMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LxSZueVMjuvlNl5pczOK2V2Ximz80qZnVfK7LyGzM5ryOy8hszOa8jsvMaXyhk7ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5DZuc1ZHZeQ2bnNWR2XkNm5zVkdl5TZuc1ZXZeU2bnNWV2XvNL5YydMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ps/OaMjuvKbPzmjI7rymz85oyO68ls/NaMjuvJbPzWjI7r/WlcsYumZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZndeS2XktmZ3Xktl5LZmd15LZeS2ZnVfJ7LxKZudVMjuvktl51ZfKGVsyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvEpm51UyO6+S2XmVzM6rZHZeJbPzKpmdV8nsvLbMzmvL7Ly2zM5ry+y89pfKGbtldl5bZue1ZXZeW2bntWV2Xltm57Vldl5bZue1ZXZeW2bntWV2Xltm57Vldl5bZue1ZXZeW2bntWV2Xltm57Vldl5bZue1ZXZeW2bntWV2Xltm57Vldl5bZue1ZXZe+72d1/l/8veduOV7d/LWGfvRO3nrjP3onbx1xn70Tt46Yz96J2+dsR+9k7fO2I/eyVtn7Cfv5L2d10fv5K0z9qN3InPGvrfz+uidyJyx7+28PnonMmfsezuvj96JzBn73s7rk3fy3s7ro3cic8a+t/P66J3InLHv7bw+eicyZ+x7O6+P3onMGfvezuujdyJzxr638/roncicse/tvD56JzJn7Hs7r4/eicwZ+97O66N3InPGvrfz+uidyJyx7+28PnonMmfsezuvj96JzBn73s7ro3cic8a+t/P66J3InLHv7bw+eicyZ+x7O6+P3onMGfvezuujdyJzxr638/roncicse/tvD56JzJn7Hs7r4/eicwZ+97O66N3InPGvrfz+uidyJyx7+28PnonMmfsezuvj96JzBn73s7ro3eicsba13tDr8/eisope25F5Zg9t6Jyzp5bUTloz62onLTnVlSO2nMrKmftuRWVw/bcis5p+97k67O3onPavjf6+uyt6Jy2782+PnsrOqfte8Ovz96Kzmn73vTrs7eic9q+N/767K3onLbvzb8+eys6p+17A7DP3orOafveBOyzt6Jz2r43Avvsreictu/NwD57KzqnrcwQ7NyKzmkrMwU7t6Jz2sqMwc6t6Jy2MnOwcys6p63MIOzcis5pKzMJO7eic9rKjMLOreictjKzsHMrOqetzDDs3IrOaSszDTu3onPayozDzq3onLYy87BzKzqnrcxA7NyKzmkrMxE7t6Jz2sqMxM6t6Jy2MjOxcys6p63MUOzcis5pKzMVO7eic9rKjMXOreictjJzsXMrOqetzGDs3IrOaSszGTu3onPayozGzq3onLYys7FzKzqnrcxw7NyKzmkrMx07t6Jz2sqMx86t6Jy2MvOxcys6p63MgOzcis5pKzMhO7eic9rKjMjOreictjIzsnMrOqetzJDs3IrOaSszJTu3InPams6WzHS2ZKazJTOdLZl9yZy2prMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdLZkprMlM50tmelsyUxnS2Y6WzLT2ZKZzpbMdbZkrrMlc50tmetsyfxL5rR1nS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmSusyVznS2Z62zJXGdL5jpbMtfZkrnOlsx1tmShsyULnS1Z6GzJQmdLFl8yp23obMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJQudLVnobMlCZ0sWOluy0NmShc6WLHS2ZKGzJUudLVnqbMlSZ0uWOluy/JI5bVNnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50tWepsyVJnS5Y6W7LU2ZKlzpYsdbZkqbMlS50t2dDZkg2dLdnQ2ZINnS3Z+JI5bYfOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOhsyYbOlmzobMmGzpZs6GzJhs6WbOpsyabOlmzqbMmmzpZsfsmctlNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLNnW2ZFNnSzZ1tmRTZ0s2dbZkU2dLtnS2ZEtnS7Z0tmRLZ0u2vmRO26WzJVs6W7KlsyVbOluypbMlWzpbsqWzJVs6W7KlsyVbOluypbMlWzpbsqWzJVs6W7KlsyVbOluypbMlWzpbsqWzJVs6W7KlsyVbOluypbMlWzpbsqWzJVs6W7KlsyVbOluypbMlWzpbsqWzJVs6W7KlsyVbOluypbMlWzpbsqWzJVs6W7KlsyVbOluypbMlWzpbsqWz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62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+T2etk9jqZvU5mr5PZ62T2Opm9Tmavk9nrZPY6mb1OZq+L2eti9rqYvS5mr4vZ62L2upi9rp41fc0/UvG1fodq/U61P/9rqv3xX1PtT/+aan/411T7s7+m2h/9NdU+n9dU+3heU+3TeUv1mHlNoW70lHlNoW70kHlNoW70jHlNoW70iHlNoW70hHlNoW70gHlNoW70fHlNoW70eHlNoW70dHlNoW70cHlNoW70bHlNoW70aHlNoW70ZHlNoW70YHlNoW70XHlNoW70WHlNoW70VHlNoW70UHlNoW70THlNoW70SHlNoW70RHlNoW70QHlNoW70PHlNoW70OHlNoW70NHlNoW70MHlNoW70LHlNoW70KHlNoW70JHlNoW70IHlNoW70HHlNoW70GHlNoW70FHlNoW70EHlNoW70DHlNoW70CHlNoW70BHlNoW70AHlNoW70/HhNkW5Uj4/XFOlG9fR4TZFuVA+P1xTpRvXseE2RblT/wec1hbqBXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27k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0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KKFXLSQixZy0UIuWshFC7loIRct5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27kohu56EYuupGLbuSiG7noRi66kYtu5KIbuehGLrqRi27iovlFXPSkQDdOCnTjpEA3Tgp046RAN04KdOOkQDdOCnTjpFA3iIueFOoGcdGTQt0gLnpSqBvERU8KdYO46EmhbhAXPSnUDeKiJ4W6QVz0pFA3iIueFOoGcdGTQt0gLnpSqBvERU8KdYO46EmhbhAXPSnUDeKiJ4W6QVz0pFA3iIueFOoGcdGTQt0gLnpSqBvERU8KdYO46EmhbhAXPSnUDeKiJ4W6QVz0pFA3iIueFOoGcdGTQt0gLnpSqBvERU8KdYO46EmhbhAXPSnUDeKiJ4W6QVz0pFA3iIueFOoGcdGTQt0gLnpSqBvERU8KdYO46EmhbhAXPSnUDeKiJ4W6QVz0pFA3iIueFOoGcdGTQt0gLnpSqBvERU8KdYO46EmRbhhyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIRc15KKGXNSQixpyUUMuashFDbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRizpyUUcu6shFHbmoIxd15KKOXNSRiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIBcN5KKBXDSQiwZy0UAuGshFA7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLDuSiA7noQC46kIsO5KIDuehALjqQiw7kogO56EAuOpCLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYtO5KITuehELjqRi07kohO56EQuOpGLTuSiE7noRC46kYvOXh3niD9Sc8wu1f7kr6n2p7HK/kitvbtU+9O4ptqfxi3V69xfU/XVptqfYc3fqe1dqv0ZXlNte6+ptr0V/jsVXar9fV1T7e/rmmp/X9dUe7JdU+3Jdkv1OndN9d24pfpu3FJ9N24p1I1e564p1I1e564p1I1e526pXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdSNXueuKdKN1evcNUW6sXqdu6ZIN1avc9cU6cbqde6aIt1Yvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gbvc5dU6gb/VeL1xTqRv/V4jWFutH74TWFutF/tXhNoW70VnlNoW70Xy1eU6gbvYteU6gbDy56S6FuIBddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVcdCEXXchFF3LRhVx0IRddyEUXctGFXHQhF13IRRdy0YVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEULuWghFy3kooVctJCLFnLRQi5ayEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93IRTdy0Y1cdCMX3chFN3LRjVx0IxfdyEU3ctGNXHQjF93ERccXcdGTAt04KdCNkwLdOCnQjZMC3Tgp0I2TAt04KdCNk0LdIC56UqgbxEVPCnWDuOhJoW4QFz0p1A3ioieFukFc9KRQN4iLnhTqBnHRk0LdIC56UqgbxEVPCnWDuOhJoW4QFz0p1A3ioieFukFc9KRQN4iLnhTqBnHRk0LdIC56UqgbxEVPCnWDuOhJoW4QFz0p1A3ioieFukFc9KRQN4iLnhTqBnHRk0LdIC56UqgbxEVPCnWDuOhJoW4QFz0p1A3ioieFukFc9KRQN4iLnhTqBnHRk0LdIC56UqgbxEVPCnWDuOhJoW4QFz0p1A3ioieFukFc9KRQN4iLnhTqBnHRk0LdIC56UqgbxEVPCnWDuOhJoW4QFz0p1A3ioidFumHIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSihlzUkIsaclFDLmrIRQ25qCEXNeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLurIRR25qCMXdeSijlzUkYs6clFHLhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSigVw0kIsGctFALhrIRQO5aCAXDeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIXTeSiiVw0kYsmctFELprIRRO5aCIX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5GBfmO+eHOwL892Tg31hvntysC/Md08O9oX57snBvjDfPTnWF4O+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd816LsGfdeg7xr0XYO+a9B3DfquQd916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+69B3HfquQ9916LsOfdeh7zr0XYe+672bjhz1R26Mr/E7l+t3rv09vJBrfw8v5Nrfwwu59vfwQq79PdxzvZu+kGuf2xdy7XP7Qq59bl/Iwb70bvpCDvald9MXcrAvvZvec72bvpCDfend9IUc7Evvpi/kYF96N30hB/vSu+kLOdiX3k1fyMG+9G76Qg72pXfTF3KwL72bvpCDfend9IUc7Evvpi/kYF96N30hB/vSu+kLOdiX3k1fyMG+9G76Qg72pXfTF3KwL72bvpCDfend9IUc7Evvpi/kYF96N30hB/vSu+kLOdiX3k1fyMG+9G76Qg72pXfTF3KwL72bvpCDfend9IUc7Evvpi/kYF96N30hB/vSu+kLOdiX3k1fyLG+RO+mL+RYX6J30xdyrC/Ru+kLOdaX6N30hRzrS/Ru+kIO9qV30xdysC+9m76Qg33p3fSFHOxL76Yv5GBfejd9IQf70rvpCznYl/672BdysC/QdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfjQffnfnr/cP/+k8Cd7m+L/dc35d7ru/LPdf35Zp78N17ru/LPdf35Z7r+3LP9X2552BfHnz3noN9efDdew725cF37znYlwffvedgXx58956DfXnw3XsO9uXBd+852JcH373nYF8efPeeg3158N17DvblwXfvOdiXB9+952BfHnz3noN9efDdew725cF37znYlwffvedgXx58956DfXnw3XsO9uXBd+852JcH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"
    ],
    "fileMap": {
      "1": {
        "source": "contract Counter {\n    use dep::aztec::{\n        context::{PrivateContext, Context},\n        note::{\n            note_header::NoteHeader,\n            utils as note_utils,\n        },\n        state_vars::map::Map,\n    };\n    use dep::value_note::{\n            balance_utils,\n            value_note::{\n                ValueNoteMethods,\n                VALUE_NOTE_LEN,\n            },\n    };\n    use dep::easy_private_state::easy_private_state::EasyPrivateUint;\n\n    struct Storage {\n        counters: Map<EasyPrivateUint>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                counters: Map::new(\n                    context,\n                    1,\n                    |context, slot| {\n                        EasyPrivateUint::new(context, slot)\n                    },\n                ),\n            }\n        }\n    }\n\n    #[aztec(private)]\n    fn constructor(headstart: u120, owner: Field) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n\n    #[aztec(private)]\n    fn increment(owner: Field)  {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n\n    unconstrained fn get_counter(owner: Field) -> Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n\n    unconstrained fn compute_note_hash_and_nullifier(\n    contract_address: Field,\n    nonce: Field,\n    storage_slot: Field,\n    preimage: [Field; VALUE_NOTE_LEN],\n    ) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n        note_utils::compute_note_hash_and_nullifier(ValueNoteMethods, note_header, preimage)\n    }\n}",
        "path": "/home/josh/Documents/GitHub/acct-abst-wrkshp/contracts/counter/src/main.nr"
      },
      "17": {
        "source": "struct GrumpkinScalar {\n    low: Field,\n    high: Field,\n}\n\nimpl GrumpkinScalar {\n    pub fn new(low: Field, high: Field) -> Self {\n        // TODO: check that the low and high value fit within the grumpkin modulus\n        GrumpkinScalar { low, high }\n    }\n}\n\nglobal GRUMPKIN_SCALAR_SERIALIZED_LEN: Field = 2;\n\npub fn deserialize_grumpkin_scalar(fields: [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN]) -> GrumpkinScalar {\n    GrumpkinScalar { low: fields[0], high: fields[1] }\n}\n\npub fn serialize_grumpkin_scalar(scalar: GrumpkinScalar) -> [Field; GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n    [scalar.low, scalar.high]\n}\n",
        "path": "std/grumpkin_scalar.nr"
      },
      "18": {
        "source": "use crate::grumpkin_scalar::GrumpkinScalar;\nuse crate::scalar_mul::fixed_base_embedded_curve;\n\npub fn grumpkin_fixed_base(scalar: GrumpkinScalar) -> [Field; 2] {\n    // TODO: this should use both the low and high limbs to do the scalar multiplication\n    fixed_base_embedded_curve(scalar.low, scalar.high)\n}\n",
        "path": "std/grumpkin_scalar_mul.nr"
      },
      "33": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "36": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/abi.nr"
      },
      "37": {
        "source": "use crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n  pedersen_hash([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/address.nr"
      },
      "39": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/context.nr"
      },
      "40": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n  let sha256_hashed = sha256(bytes_to_hash);\n\n  // Convert it to a field element\n  let mut v = 1;\n  let mut high = 0 as Field;\n  let mut low = 0 as Field;\n\n  for i in 0..16 {\n      high = high + (sha256_hashed[15 - i] as Field) * v;\n      low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n      v = v * 256;\n  }\n\n  // Abuse that a % p + b % p = (a + b) % p and that low < p\n  let hash_in_a_field = low + high * v;\n\n  hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n  // TODO(#1205) This is probably not the right index to use\n  pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n  pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/hash.nr"
      },
      "41": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(\n    context: &mut PublicContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/log.nr"
      },
      "46": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let preimage = serialize(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/lifecycle.nr"
      },
      "47": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/note_getter.nr"
      },
      "49": {
        "source": "use crate::hash::pedersen_hash;\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/note_hash.nr"
      },
      "53": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/utils.nr"
      },
      "60": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n  get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n  let result = get_public_key_and_partial_address_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/get_public_key.nr"
      },
      "61": {
        "source": "use crate::oracle::get_public_key::get_public_key;\nuse crate::types::point::Point;\n\n#[oracle(getSecretKey)]\nfn get_secret_key_oracle(\n    _owner: Point,\n) -> [Field; dep::std::grumpkin_scalar::GRUMPKIN_SCALAR_SERIALIZED_LEN] {\n}\n\nunconstrained fn get_secret_key_internal(owner_public_key: Point) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    dep::std::grumpkin_scalar::deserialize_grumpkin_scalar(get_secret_key_oracle(owner_public_key))\n}\n\npub fn get_secret_key(owner: Field) -> dep::std::grumpkin_scalar::GrumpkinScalar {\n    let owner_public_key = get_public_key(owner);\n    let secret = get_secret_key_internal(owner_public_key);\n\n    // Constrain the owner - Nullifier secret key is currently just the encryption private key so we can constrain\n    // the owner by deriving the public key from the secret key and checking the result.\n    let computed_public_key = dep::std::grumpkin_scalar_mul::grumpkin_fixed_base(secret);\n    assert(owner_public_key.x == computed_public_key[0]);\n    assert(owner_public_key.y == computed_public_key[1]);\n\n    secret\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/get_secret_key.nr"
      },
      "62": {
        "source": "\n\n#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/rand.nr"
      },
      "65": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(preimage);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/notes.nr"
      },
      "67": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T)  -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/logs.nr"
      },
      "73": {
        "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse crate::hash::pedersen_hash;\n\n// docs:start:map\nstruct Map<V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<V> Map<V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Map<V> {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map {\n            context,\n            storage_slot,\n            state_var_constructor,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: Field) -> V {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key],0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/state_vars/map.nr"
      },
      "75": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::constants_gen::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/state_vars/set.nr"
      },
      "80": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/types/vec.nr"
      },
      "86": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/utils.nr"
      },
      "87": {
        "source": "use dep::aztec::note::{\n    note_getter::view_notes,\n    note_viewer_options::NoteViewerOptions,\n};\nuse dep::aztec::state_vars::set::Set;\nuse crate::value_note::{VALUE_NOTE_LEN, ValueNote};\n\nunconstrained pub fn get_balance(set: Set<ValueNote, VALUE_NOTE_LEN>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: Set<ValueNote, VALUE_NOTE_LEN>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/value-note/src/balance_utils.nr"
      },
      "90": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key,\n    },\n    log::emit_encrypted_log,\n    hash::pedersen_hash,\n    context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: Field,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: Field) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote {\n            value,\n            owner,\n            randomness,\n            header,\n        }\n    }\n\n    pub fn serialize(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner, self.randomness]\n    }\n\n    pub fn deserialize(preimage: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: preimage[0],\n            owner: preimage[1],\n            randomness: preimage[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn compute_note_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize(),0)\n    }\n\n    // docs:start:nullifier\n\n    pub fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(ValueNoteMethods, self);\n        let secret = get_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    pub fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(preimage: [Field; VALUE_NOTE_LEN]) -> ValueNote {\n    ValueNote::deserialize(preimage)\n}\n\nfn serialize(note: ValueNote) -> [Field; VALUE_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ValueNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ValueNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ValueNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ValueNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\n// Broadcasts the note as an encrypted log on L1.\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ValueNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ValueNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/value-note/src/value_note.nr"
      },
      "91": {
        "source": "use dep::aztec::{\n    context::Context,\n    note::note_getter_options::NoteGetterOptions,\n    state_vars::set::Set,\n};\nuse dep::value_note::{\n    filter::filter_notes_min_sum,\n    value_note::{ValueNote, ValueNoteMethods, VALUE_NOTE_LEN},\n};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: Set<ValueNote, VALUE_NOTE_LEN>,\n    storage_slot: Field,\n}\n\nimpl EasyPrivateUint {\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = Set {\n            context,\n            storage_slot,\n            note_interface: ValueNoteMethods,\n        };\n        EasyPrivateUint {\n            context,\n            set,\n            storage_slot,\n        }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u120, owner: Field) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u120, owner: Field) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u120 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner == owner);\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u120;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n",
        "path": "/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/easy-private-state/src/easy_private_state.nr"
      }
    }
  }
}